import { assert, assertEquals, assertFalse, assertNotEquals, assertThrows } from "./asserts.test.ts";
import { Dimensions } from "./dimensions.ts";
import { QuantityError } from "./error.ts";
import { Quantity } from "./quantity.ts";

const ONE_MASS_DIMENSION = new Dimensions([1, 0, 0, 0, 0, 0, 0, 0]);
const ONE_LENGTH_DIMENSION = new Dimensions([0, 1, 0, 0, 0, 0, 0, 0]);
const ONE_TEMP_DIMENSION = new Dimensions([0, 0, 0, 1, 0, 0, 0, 0]);
const TWO_LENGTH_DIMENSIONS = new Dimensions([0, 2, 0, 0, 0, 0, 0, 0]);
const THREE_LENGTH_DIMENSIONS = new Dimensions([0, 3, 0, 0, 0, 0, 0, 0]);
/** Force is mass*length/time^2 */
const FORCE_DIMENSIONS = new Dimensions([1, 1, -2, 0, 0, 0, 0, 0]);

Deno.test("Quantity instance equality", async (t) => {
    /**
     * Equality test helper.
     * Given two functions that create Quantities, make sure that the Quantities
     * generated by the first function are equal to themsevles, but not equal to
     * the Quantity generated by the second.
     */
    const check = (
        description: string,
        factory: () => Quantity,
        other: () => Quantity,
    ) => {
        const q1a = factory();
        const q1b = factory();
        const q2 = other();
        return t.step(description, () => {
            assert(q1a.equals(q1b));
            assertFalse(q1a.equals(q2));
            assertFalse(q2.equals(q1b));
            // Also check that the built-in deep equals agrees:
            assertEquals(q1a, q1b);
            assertNotEquals(q1a, q2);
        });
    };

    // The first number should equal itself but not equal the second:
    await check(
        "dimensionless number",
        () => new Quantity(15),
        () => new Quantity(12),
    );
    await check(
        "negative dim'less number",
        () => new Quantity(-50),
        () => new Quantity(12),
    );
    await check(
        "Zero",
        () => new Quantity(0),
        () => new Quantity(1),
    );
    await check(
        "Different dimensions, same magnitude",
        // This one will equal itself:
        () => new Quantity(15, { dimensions: new Dimensions([1, 0, 0, 0, 0, 0, 0, 0]) }),
        // But the one above won't equal this one, with different dimensions:
        () => new Quantity(15, { dimensions: new Dimensions([0, 1, 0, 0, 0, 0, 0, 0]) }),
    );
    await check(
        "Different dimensions, same magnitude (2)",
        () => new Quantity(0, { dimensions: new Dimensions([1, 0, 0, 0, 0, 0, 0, 0]) }),
        () => new Quantity(0, { dimensions: new Dimensions([0, 0, 0, 0, 0, 0, 0, 0]) }),
    );
    await check(
        "Different dimensions, same magnitude (3)",
        () => new Quantity(-10, { dimensions: new Dimensions([1, 0, 0, 1, 2, 0, 0, 0]) }),
        () => new Quantity(-10, { dimensions: new Dimensions([1, 0, 0, 1, 1, 0, 0, 0]) }),
    );
    await check(
        "Different custom dimensions, same magnitude and regular dimensions",
        () =>
            new Quantity(-10, {
                // deno-fmt-ignore
                dimensions: new Dimensions([0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1], ["a", "b", "c", "d"]),
            }),
        () =>
            new Quantity(-10, {
                dimensions: new Dimensions(
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
                    ["a", "b", "c", "d"],
                ),
            }),
    );
    await check(
        "Different custom dimension names, same magnitude and dimension values",
        () =>
            new Quantity(-10, {
                dimensions: new Dimensions(
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2],
                    ["a", "b", "c", "d"],
                ),
            }),
        () =>
            new Quantity(-10, {
                dimensions: new Dimensions(
                    [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 2],
                    ["a", "b", "c", "elf"],
                ),
            }),
    );
});

Deno.test("Constructing Quantity instances with units", async (t) => {
    await t.step(`new Quantity(15, {units: "m"})`, () => {
        const q = new Quantity(15, { units: "m" });
        assertEquals(q.magnitude, 15);
        assertEquals(q.dimensions, ONE_LENGTH_DIMENSION);
    });

    await t.step(`new Quantity(15, {units: "km"})`, () => {
        const q = new Quantity(15, { units: "km" });
        assertEquals(q.magnitude, 15000);
        assertEquals(q.dimensions, ONE_LENGTH_DIMENSION);
    });

    await t.step(`new Quantity(3, {units: "km^2"})`, () => {
        const q = new Quantity(3, { units: "km^2" });
        // 3 km^2 is 3e6 m^2:
        assertEquals(q.magnitude, 3_000_000);
        assertEquals(q.dimensions, TWO_LENGTH_DIMENSIONS);
    });

    await t.step(`new Quantity(400, {units: "mm^3"})`, () => {
        const q = new Quantity(400, { units: "mm^3" });
        // 400 cubic milimeters is 4e-7 cubic meters.
        // But if we write 400e-7 we get a tiny error due to binary vs. decimal math,
        // so we have to write it as 400 * 1e-9, which is how this gets computed.
        assertEquals(q.magnitude, 400 * 1e-9);
        assertEquals(q.dimensions, THREE_LENGTH_DIMENSIONS);
    });

    await t.step(`new Quantity(12, {units: "kg⋅m/s^2"})`, () => {
        const q = new Quantity(12, { units: "kg⋅m/s^2" });
        assertEquals(q.magnitude, 12);
        assertEquals(q.dimensions, FORCE_DIMENSIONS);
    });
});

Deno.test("Adding quantities", async (t) => {
    await t.step(`cannot add units of different dimensions`, () => {
        const x = new Quantity(5, { units: "m" });
        const y = new Quantity(3);
        assertThrows(
            () => {
                x.add(y);
            },
            QuantityError,
            `Cannot add quanitites with different units.`,
        );
    });
    await t.step(`cannot add units of different dimensions (2)`, () => {
        const x = new Quantity(5, { units: "m" });
        const y = new Quantity(3, { units: "m^2" });
        assertThrows(
            () => {
                x.add(y);
            },
            QuantityError,
            `Cannot add quanitites with different units.`,
        );
    });
    await t.step(`cannot add units of different dimensions (3)`, () => {
        const x = new Quantity(5, { units: "m" });
        const y = new Quantity(3, { units: "g" });
        assertThrows(
            () => {
                x.add(y);
            },
            QuantityError,
            `Cannot add quanitites with different units.`,
        );
    });
    await t.step(`(25 g) + (17 g)`, () => {
        const x = new Quantity(25, { units: "g" });
        const y = new Quantity(17, { units: "g" });
        const z = x.add(y);
        assertEquals(z.magnitude, 0.042);
        assertEquals(z.dimensions, ONE_MASS_DIMENSION);
        assertEquals(z, y.add(x));
    });
    await t.step(`(5 kg) + (500 g)`, () => {
        const x = new Quantity(5, { units: "kg" });
        const y = new Quantity(500, { units: "g" });
        const z = x.add(y);
        assertEquals(z.magnitude, 5.5);
        assertEquals(z.dimensions, ONE_MASS_DIMENSION);
        assertEquals(z, y.add(x));
    });
    await t.step(`(5 kg) + (-500 g)`, () => {
        const x = new Quantity(5, { units: "kg" });
        const y = new Quantity(-500, { units: "g" });
        const z = x.add(y);
        assertEquals(z.magnitude, 4.5);
        assertEquals(z.dimensions, ONE_MASS_DIMENSION);
        assertEquals(z, y.add(x));
    });

    // Adding temperatures:
    await t.step(`temperatures in Kelvin add normally: (100 K) + (25 K) = (125 K)`, () => {
        const x = new Quantity(100, { units: "K" });
        const y = new Quantity(25, { units: "K" });
        const z = x.add(y);
        assertEquals(z.magnitude, 125);
        assertEquals(z.dimensions, ONE_TEMP_DIMENSION);
        assertEquals(z, y.add(x));
    });
    await t.step(`an exact temperature in °C can have a ΔC added to it.`, () => {
        const x = new Quantity(100, { units: "degC" });
        const y = new Quantity(25, { units: "deltaC" });
        const z = x.add(y);
        assertEquals(z.magnitude, 273.15 + 125); // in K
        assertEquals(z.dimensions, ONE_TEMP_DIMENSION);
    });
});

Deno.test("Multiplying quantities", async (t) => {
    await t.step(`(5 m) * (3)`, () => {
        const x = new Quantity(5, { units: "m" });
        const y = new Quantity(3);
        const z = x.multiply(y);
        assertEquals(z.magnitude, 15);
        assertEquals(z.dimensions, ONE_LENGTH_DIMENSION); // m
    });
    await t.step(`(5 m) * (3 m)`, () => {
        const x = new Quantity(5, { units: "m" });
        const y = new Quantity(3, { units: "m" });
        const z = x.multiply(y);
        assertEquals(z.magnitude, 15);
        assertEquals(z.dimensions, TWO_LENGTH_DIMENSIONS); // m²
    });
    await t.step(`(500 g) * (2 m/s^2)`, () => {
        const x = new Quantity(500, { units: "g" });
        const y = new Quantity(2, { units: "m/s^2" });
        const z = x.multiply(y);
        // equals 1 kg⋅m/s² (units of force)
        assertEquals(z.magnitude, 1.0);
        assertEquals(z.dimensions, FORCE_DIMENSIONS);
    });
});

Deno.test("Uncertainty/tolerance", async (t) => {
    await t.step(`a number can have an uncertainty/tolerance value specified`, () => {
        const x = new Quantity(5, { units: "m", plusMinus: 0.02 });
        assertEquals(x.magnitude, 5);
        assertEquals(x.plusMinus, 0.02);
        // assertEquals(x.toString(), "5±0.02 m"); // TODO: uncomment this.
    });

    await t.step(`when multiplying two quantities, the relative error is added.`, () => {
        // x = (4.52 ± 0.02) cm, y = (2.0 ± 0.2) cm.
        // Then z = xy = 9.04 ± 0.944 cm² which rounds to 9.0 ± 0.9 cm²
        const x = new Quantity(4.52, { units: "cm", plusMinus: 0.02 });
        const y = new Quantity(2.0, { units: "cm", plusMinus: 0.2 });
        const z = x.multiply(y);
        assertEquals(z.magnitude, 9.04e-4);
        assertEquals(z.plusMinus, 0.944e-4);
        // assertEquals(z.toString(), "9.0±0.9 cm²"); // TODO: uncomment this.
    });
});
